# 简单总结你实现的功能
实现了一个sys_task_info系统调用。通过调用该系统调用，可以查询当前正在执行的任务信息（包括任务控制块相关信息（任务状态）、任务使用的系统调用及调用次数、系统调用时刻距离任务第一次被调度时刻的时长（单位ms））。

# 问答题
1. 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容（运行 三个 bad 测例 (ch2b_bad_*.rs) ）， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。
   [kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x804003a4, kernel killed it.  
   sbi: RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0

2. 深入理解 trap.S 中两个函数 __alltraps 和 __restore 的作用，并回答如下问题:
    1. L40：刚进入 __restore 时，a0 代表了什么值。请指出 __restore 的两种使用情景。  
       a0: cx_ptr保存的值,任务的trapContext   
       使用情景: 
       * 开始运行app
       * 处理完trap后，回到用户态时

    2. L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。
       ```
        ld t0, 32*8(sp)
        ld t1, 33*8(sp)
        ld t2, 2*8(sp)
        csrw sstatus, t0
        csrw sepc, t1
        csrw sscratch, t2
       ```
       sstatus: SPP 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息。可以通过它知道是否应该进入用户态  
       sepc: 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址。进入用户态时可以通过它知道该回哪个地址  
       sscratch: 进入用户态时，sscratch 寄存器的值可以被用来恢复用户态的上下文，如保存的程序计数器或其他寄存器状态。

    3. L50-L56：为何跳过了 x2 和 x4？
       ```
        ld x1, 1*8(sp)
        ld x3, 3*8(sp)
        .set n, 5
        .rept 27
           LOAD_GP %n
           .set n, n+1
        .endr
       ```
       x2：在 __alltraps 函数中已经通过 csrrw sp, sscratch, sp 修改了栈指针，不需要再次保存。   
       x4：线程指针通常在用户程序中不需要访问。

    4. L60：该指令之后，sp 和 sscratch 中的值分别有什么意义？
       ```
        csrrw sp, sscratch, sp
       ```
       sp: 指向kernel stack  
       sscratch: 指向user stack

    5. __restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？  
       sret  
       因为他代表__restore运行结束了

    6. L13：该指令之后，sp 和 sscratch 中的值分别有什么意义？
       ```
        csrrw sp, sscratch, sp
       ```
       sp: 指向user stack  
       sscratch: 指向kernel stack

    7. 从 U 态进入 S 态是哪一条指令发生的？
       ecall

# 荣誉准则  
1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
   群友atomicity_wish

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
   rCore-Camp-Guide-2024A 文档, 训练营课程

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。  

# 看法
刚开始做的时候真的觉得特别难，不知道该怎么下手。把课程教材从ch1看到ch3后，感觉懵懵懂懂的，但是有点想法和思路了。总体来说我觉得实验设计非常好，循序渐进，逐渐从零开始学内核是个什么玩意，用户态与内核态又是什么关系等等。难度我觉得是你静下心来努力思考，努力动脑子，努力尝试就不算难。对我是一个很大的进步，感谢训练营。